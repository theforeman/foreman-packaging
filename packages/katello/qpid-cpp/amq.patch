From 65044e8ac82257d35f87addaeeabafdb6ec051c0 Mon Sep 17 00:00:00 2001
From: Kim van der Riet <kvdr@localhost.localdomain>
Date: Fri, 7 Jun 2019 12:39:40 -0400
Subject: [PATCH 1/5] Bug 1715165,QPID-8320: Fix for empty journal file leak
 when linearstore recovers

---
 management/python/lib/qlslibs/analyze.py      |  2 +-
 .../linearstore/journal/RecoveryManager.cpp   | 32 +++++++++++++++----
 .../linearstore/journal/RecoveryManager.h     |  2 ++
 src/qpid/linearstore/journal/jcntl.cpp        |  1 +
 4 files changed, 30 insertions(+), 7 deletions(-)

diff --git a/management/python/lib/qlslibs/analyze.py b/management/python/lib/qlslibs/analyze.py
index 8c5de05b9..b3551e8a9 100644
--- a/management/python/lib/qlslibs/analyze.py
+++ b/management/python/lib/qlslibs/analyze.py
@@ -505,7 +505,7 @@ class Journal(object):
             self.statistics.filler_record_count += 1
             ok_flag = True
             if self.args.show_all_recs:
-                print '0x%x:%s' % (start_journal_file.file_header.file_num, this_record)
+                print '0x%x:%s' % (start_journal_file.file_header.file_num, this_record.to_rh_string())
         qlslibs.utils.skip(self.current_journal_file.file_header.file_handle, qlslibs.utils.DEFAULT_DBLK_SIZE)
         return ok_flag
     def _handle_enqueue_record(self, enqueue_record, start_journal_file):
diff --git a/src/qpid/linearstore/journal/RecoveryManager.cpp b/src/qpid/linearstore/journal/RecoveryManager.cpp
index 185fa00cb..be0ed8af2 100644
--- a/src/qpid/linearstore/journal/RecoveryManager.cpp
+++ b/src/qpid/linearstore/journal/RecoveryManager.cpp
@@ -298,12 +298,7 @@ void RecoveryManager::recoveryComplete() {
 void RecoveryManager::setLinearFileControllerJournals(lfcAddJournalFileFn fnPtr,
                                                       LinearFileController* lfcPtr) {
     if (journalEmptyFlag_) {
-        if (uninitFileList_.size() > 0) {
-            // TODO: Handle case if uninitFileList_.size() > 1, but this should not happen in normal operation. Here we assume only one item in the list.
-            std::string uninitFile = uninitFileList_.back();
-            uninitFileList_.pop_back();
-            lfcPtr->restoreEmptyFile(uninitFile);
-        }
+        restoreEmptyFile(lfcPtr);
     } else {
         if (initial_fid_ == 0) {
             throw jexception(jerrno::JERR_RCVM_NULLFID, "RecoveryManager", "setLinearFileControllerJournals");
@@ -311,6 +306,9 @@ void RecoveryManager::setLinearFileControllerJournals(lfcAddJournalFileFn fnPtr,
         for (fileNumberMapConstItr_t i = fileNumberMap_.begin(); i != fileNumberMap_.end(); ++i) {
             (lfcPtr->*fnPtr)(i->second->journalFilePtr_, i->second->completedDblkCount_, i->first == initial_fid_);
         }
+        if (lastFileFullFlag_) {
+            restoreEmptyFile(lfcPtr);
+        }
     }
 
     std::ostringstream oss;
@@ -328,6 +326,16 @@ void RecoveryManager::setLinearFileControllerJournals(lfcAddJournalFileFn fnPtr,
     }
 }
 
+void RecoveryManager::restoreEmptyFile(LinearFileController* lfcPtr) {
+    if (uninitFileList_.size() > 0) {
+        std::string uninitFile = uninitFileList_.back();
+        uninitFileList_.pop_back();
+        lfcPtr->restoreEmptyFile(uninitFile);
+        lastFileFullFlag_ = false;
+        endOffset_ = 0;
+    }
+}
+
 std::string RecoveryManager::toString(const std::string& jid, const uint16_t indent) const {
     std::string indentStr(indent, ' ');
     std::ostringstream oss;
@@ -389,6 +397,7 @@ void RecoveryManager::analyzeJournalFileHeaders(efpIdentity_t& efpIdentity) {
             oss << "Journal file " << (*i) << " is corrupted or invalid";
             journalLogRef_.log(JournalLog::LOG_WARN, queueName_, oss.str());
         } else if (hdrEmpty) {
+/* This seems unnecessary, as the data size is encoded in the file_hdr_t::_data_size_kib, even for reset file headers
             // Read symlink, find efp directory name which is efp size in KiB
             // TODO: place this bit into a common function as it is also used in EmptyFilePool.cpp::deleteSymlink()
             char buff[1024];
@@ -406,6 +415,10 @@ void RecoveryManager::analyzeJournalFileHeaders(efpIdentity_t& efpIdentity) {
             uninitFileList_.push_back(*i);
             efpIdentity.pn_ = fileHeader._efp_partition;
             efpIdentity.ds_ = efpDataSize_kib;
+*/
+            efpIdentity.pn_ = fileHeader._efp_partition;
+            efpIdentity.ds_ = fileHeader._data_size_kib;
+            uninitFileList_.push_back(*i);
         } else if (headerQueueName.compare(queueName_) != 0) {
             std::ostringstream oss;
             oss << "Journal file " << (*i) << " belongs to queue \"" << headerQueueName << "\": ignoring";
@@ -947,4 +960,11 @@ void RecoveryManager::removeEmptyFiles(EmptyFilePool* emptyFilePoolPtr) {
     }
 }
 
+void RecoveryManager::removeUninitFiles(EmptyFilePool* emptyFilePoolPtr) {
+    while (uninitFileList_.size() > 0) {
+        emptyFilePoolPtr->returnEmptyFileSymlink(uninitFileList_.back());
+        uninitFileList_.pop_back();
+    };
+}
+
 }}}
diff --git a/src/qpid/linearstore/journal/RecoveryManager.h b/src/qpid/linearstore/journal/RecoveryManager.h
index 55cc6f832..5e237011e 100644
--- a/src/qpid/linearstore/journal/RecoveryManager.h
+++ b/src/qpid/linearstore/journal/RecoveryManager.h
@@ -123,6 +123,7 @@ public:
                                  data_tok* const dtokp,
                                  bool ignore_pending_txns);
     void recoveryComplete();
+    void removeUninitFiles(EmptyFilePool* emptyFilePoolPtr);
     void setLinearFileControllerJournals(lfcAddJournalFileFn fnPtr,
                                          LinearFileController* lfcPtr);
     std::string toString(const std::string& jid, const uint16_t indent) const;
@@ -146,6 +147,7 @@ protected:
     bool readFileHeader();
     void readJournalData(char* target, const std::streamsize size);
     void removeEmptyFiles(EmptyFilePool* emptyFilePoolPtr);
+    void restoreEmptyFile(LinearFileController* lfcPtr);
 
     static bool readJournalFileHeader(const std::string& journalFileName,
                                       ::file_hdr_t& fileHeaderRef,
diff --git a/src/qpid/linearstore/journal/jcntl.cpp b/src/qpid/linearstore/journal/jcntl.cpp
index f207b9b88..ffa379c5c 100644
--- a/src/qpid/linearstore/journal/jcntl.cpp
+++ b/src/qpid/linearstore/journal/jcntl.cpp
@@ -122,6 +122,7 @@ jcntl::recover(EmptyFilePoolManager* efpmp,
     _jrnl_log.log(/*LOG_DEBUG*/JournalLog::LOG_INFO, _jid, _recoveryManager.toString(_jid, 5U));
     _linearFileController.initialize(_jdir.dirname(), _emptyFilePoolPtr, _recoveryManager.getHighestFileNumber());
     _recoveryManager.setLinearFileControllerJournals(&qpid::linearstore::journal::LinearFileController::addJournalFile, &_linearFileController);
+    _recoveryManager.removeUninitFiles(_emptyFilePoolPtr);
     if (_recoveryManager.isLastFileFull()) {
         _linearFileController.getNextJournalFile();
     }
-- 
2.20.1

From 2974188b47bc230472c51ea1f351e5205b785566 Mon Sep 17 00:00:00 2001
From: Mike Cressman <mcressman@redhat.com>
Date: Fri, 17 Aug 2018 22:30:53 -0400
Subject: [PATCH 2/5] Bug 1618908 - client memory leak when attaching to an
 unreachable broker address

---
 src/qpid/sys/posix/AsynchIO.cpp | 1 +
 1 file changed, 1 insertion(+)

diff --git a/src/qpid/sys/posix/AsynchIO.cpp b/src/qpid/sys/posix/AsynchIO.cpp
index a05e66f54..78ed62275 100644
--- a/src/qpid/sys/posix/AsynchIO.cpp
+++ b/src/qpid/sys/posix/AsynchIO.cpp
@@ -191,6 +191,7 @@ void AsynchConnector::start(Poller::shared_ptr poller)
 void AsynchConnector::stop()
 {
     stopWatch();
+    DispatchHandle::doDelete();
 }
 
 void AsynchConnector::requestCallback(RequestCallback callback) {
-- 
2.20.1

From 499e5f916b07170b6ea6e97d4c540b8a26857d15 Mon Sep 17 00:00:00 2001
From: Mike Cressman <mcressman@redhat.com>
Date: Tue, 8 Jan 2019 10:55:13 -0500
Subject: [PATCH 3/5] Bug 1663609 - fix CLOSE_WAIT leak in qpid-cpp-client when
 trying to reconnect over unreliable network

---
 src/qpid/client/TCPConnector.cpp | 8 +++++++-
 src/qpid/client/TCPConnector.h   | 1 +
 2 files changed, 8 insertions(+), 1 deletion(-)

diff --git a/src/qpid/client/TCPConnector.cpp b/src/qpid/client/TCPConnector.cpp
index 0a570fb1d..3ecb67fc6 100644
--- a/src/qpid/client/TCPConnector.cpp
+++ b/src/qpid/client/TCPConnector.cpp
@@ -161,7 +161,7 @@ void TCPConnector::abort() {
     if (!closed) {
         if (aio) {
             // Established connection
-            aio->requestCallback(boost::bind(&TCPConnector::disconnected, this, _1));
+            aio->requestCallback(boost::bind(&TCPConnector::aborted, this, _1));
         } else if (connector) {
             // We're still connecting
             connector->requestCallback(boost::bind(&TCPConnector::connectAborted, this));
@@ -314,6 +314,12 @@ void TCPConnector::disconnected(AsynchIO&) {
     socketClosed(*aio, *socket);
 }
 
+void TCPConnector::aborted(AsynchIO&) {
+    closed = true;
+    socketClosed(*aio, *socket);
+    socket->close();
+}
+
 void TCPConnector::activateSecurityLayer(std::auto_ptr<qpid::sys::SecurityLayer> sl)
 {
     securityLayer = sl;
diff --git a/src/qpid/client/TCPConnector.h b/src/qpid/client/TCPConnector.h
index 20bd2fa5b..11eb627bf 100644
--- a/src/qpid/client/TCPConnector.h
+++ b/src/qpid/client/TCPConnector.h
@@ -102,6 +102,7 @@ protected:
     void writebuff(qpid::sys::AsynchIO&);
     void eof(qpid::sys::AsynchIO&);
     void disconnected(qpid::sys::AsynchIO&);
+    void aborted(qpid::sys::AsynchIO&);
     void socketClosed(qpid::sys::AsynchIO&, const qpid::sys::Socket&);
 
 public:
-- 
2.20.1

From dbe8c71e42fb33264900b08bbc7e5b60f06d2823 Mon Sep 17 00:00:00 2001
From: Mike Cressman <mcressman@redhat.com>
Date: Fri, 15 Mar 2019 10:49:11 -0400
Subject: [PATCH 4/5] Bug 1687401/1663609 - close socket before calling
 socketClosed callback

Fixes sporadic segfault
---
 src/qpid/client/TCPConnector.cpp | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/src/qpid/client/TCPConnector.cpp b/src/qpid/client/TCPConnector.cpp
index 3ecb67fc6..2bdc7223b 100644
--- a/src/qpid/client/TCPConnector.cpp
+++ b/src/qpid/client/TCPConnector.cpp
@@ -316,8 +316,8 @@ void TCPConnector::disconnected(AsynchIO&) {
 
 void TCPConnector::aborted(AsynchIO&) {
     closed = true;
-    socketClosed(*aio, *socket);
     socket->close();
+    socketClosed(*aio, *socket);
 }
 
 void TCPConnector::activateSecurityLayer(std::auto_ptr<qpid::sys::SecurityLayer> sl)
-- 
2.20.1

From 50ed2089cb0510c69b3f84388eeaf1cb25c5d5b2 Mon Sep 17 00:00:00 2001
From: Cliff Jansen <cliffjansen@apache.org>
Date: Mon, 13 Jul 2020 10:18:14 -0700
Subject: [PATCH 5/5] Bug 1857205,QPID-8453: fix boundary test between map8 and
 map32 encodings for AMQP 1.0 messages

---
 src/qpid/amqp/MapEncoder.cpp        | 4 +++-
 src/qpid/amqp/MapSizeCalculator.cpp | 2 +-
 2 files changed, 4 insertions(+), 2 deletions(-)

diff --git a/src/qpid/amqp/MapEncoder.cpp b/src/qpid/amqp/MapEncoder.cpp
index cf8ef4ecb..43e1954f2 100644
--- a/src/qpid/amqp/MapEncoder.cpp
+++ b/src/qpid/amqp/MapEncoder.cpp
@@ -116,9 +116,11 @@ void MapEncoder::handleString(const CharSequence& key, const CharSequence& value
 
 void MapEncoder::writeMetaData(size_t size, size_t count, const Descriptor* d)
 {
-    if (count > 255 || size > 255) {
+
+    if (count > 255 || (size+1) > 255) {
         writeMap32MetaData((uint32_t) size, (uint32_t) count, d);
     } else {
+        /* can use more compact format */
         writeMap8MetaData((uint8_t) size, (uint8_t) count, d);
     }
 }
diff --git a/src/qpid/amqp/MapSizeCalculator.cpp b/src/qpid/amqp/MapSizeCalculator.cpp
index 2da152108..4107df689 100644
--- a/src/qpid/amqp/MapSizeCalculator.cpp
+++ b/src/qpid/amqp/MapSizeCalculator.cpp
@@ -139,7 +139,7 @@ size_t MapSizeCalculator::getTotalSizeRequired(const Descriptor* d) const
     size_t result(size);
     if (d) result += d->getSize();
     result += 1/*typecode*/;
-    if (count * 2 > 255 || size > 255) {
+    if (count * 2 > 255 || (size+1) > 255) {
         result += 4/*size*/ + 4/*count*/;
     } else {
         result += 1/*size*/ + 1/*count*/;
-- 
2.20.1

