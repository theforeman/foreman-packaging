#!/bin/bash
# Wrapper around /sbin/service command.
#
# Some services do not start or stop properly and return non-zero values
# for some commands. To test it try this quick sequence:
#
#   service xxx start
#   service xxx status
#   service xxx stop
#   service xxx status
#
# This simple wrapper works with any service and just pass over the request
# to /sbin/service, but for few problematic ones it waits until service is
# fully started or stopped.
#
# To test the implementation use:
#
#   service-wait xxx test-wait
#
SERVICE=$1
COMMAND=$2

[ -f /etc/sysconfig/service-wait ] && source "/etc/sysconfig/service-wait"

# maximum time to wait (in seconds)
WAIT_MAX=${WAIT_MAX:-30}
RETRY_INTERVAL=${RETRY_INTERVAL:-1}
POSTGRES_PORT=${POSTGRES_PORT:-5432}
POSTGRES_DATA=${POSTGRES_DATA:-/var/lib/pgsql/data}
FOREMAN_TEST_URL=${FOREMAN_TEST_URL:-http://localhost:5500/foreman/api}
KATELLO_TEST_URL=${KATELLO_TEST_URL:-http://localhost:5000/katello/api}

# for some services we add few extra seconds after start
ADDITIONAL_SLEEP=5

wait_for_url() {
  RETVAL=5
  tries=0

  while [[ $RETVAL -ne 0 && $tries -lt $WAIT_MAX ]]; do
    tries=$((tries + 1))
    /usr/bin/curl -ks --noproxy '*' --cert /dev/null $1 > /dev/null
    RETVAL=$?
    sleep $RETRY_INTERVAL
  done
}

# before start or restart
before_start() {
  test 1 -eq 1 # noop
}

# after start or restart
after_start() {
  case "$SERVICE" in
    foreman)
      wait_for_url $FOREMAN_TEST_URL
      ;;
    katello)
      wait_for_url $KATELLO_TEST_URL
      ;;
    postgresql)
      for i in {1..$WAIT_MAX}; do ss -ln | grep -q ":$POSTGRES_PORT\s" && break; sleep 1; done
      # and create lock and pid files if they does not exist
      [ -f "/var/lock/subsys/postgresql" ] || touch "/var/lock/subsys/postgresql"
      [ -f "/var/run/postmaster.${POSTGRES_PORT}.pid" ] || head -n 1 "$POSTGRES_DATA/postmaster.pid" > "/var/run/postmaster.${POSTGRES_PORT}.pid"
      sleep $ADDITIONAL_SLEEP
      ;;
    httpd)
      sleep $ADDITIONAL_SLEEP
      ;;
  esac
}

after_stop() {
  test 1 -eq 1 # noop
}

before_status() {
  test 1 -eq 1 # noop
}

after_status() {
  test 1 -eq 1 # noop
}

before_enable() {
  test 1 -eq 1 # noop
}

after_enable() {
  test 1 -eq 1 # noop
}

before_disable() {
  test 1 -eq 1 # noop
}

after_disable() {
  test 1 -eq 1 # noop
}

case "$COMMAND" in
  start|stop|restart|status|enable|disable)
    before_$COMMAND
    /bin/systemctl $COMMAND "$SERVICE"
    RETVAL=$?
    after_$COMMAND
    ;;
  test-wait)
    echo -n "Starting $SERVICE... "
    /usr/sbin/service-wait "$SERVICE" "start" >/dev/null 2>&1
    [ $? -eq 0 ] && echo "OK" || echo "FAIL"
    echo -n "Querying $SERVICE... "
    /usr/sbin/service-wait "$SERVICE" "status" >/dev/null 2>&1
    [ $? -eq 0 ] && echo "OK" || echo "FAIL"
    echo -n "Stopping $SERVICE... "
    /usr/sbin/service-wait "$SERVICE" "stop" >/dev/null 2>&1
    [ $? -eq 0 ] && echo "OK" || echo "FAIL"
    echo -n "Querying $SERVICE... "
    /usr/sbin/service-wait "$SERVICE" "status" >/dev/null 2>&1
    [ ! $? -eq 0 ] && echo "OK" || echo "FAIL"
    echo -n "Starting $SERVICE... "
    /usr/sbin/service-wait "$SERVICE" "start" >/dev/null 2>&1
    [ $? -eq 0 ] && echo "OK" || echo "FAIL"
    echo -n "Querying $SERVICE... "
    /usr/sbin/service-wait "$SERVICE" "status" >/dev/null 2>&1
    [ $? -eq 0 ] && echo "OK" || echo "FAIL"
    echo -n "Stopping $SERVICE... "
    /usr/sbin/service-wait "$SERVICE" "stop" >/dev/null 2>&1
    [ $? -eq 0 ] && echo "OK" || echo "FAIL"
    ;;
  *)
    /sbin/service $1 $2
    RETVAL=$?
esac

exit $RETVAL
