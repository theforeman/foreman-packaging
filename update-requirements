#!/usr/bin/env python3
# pylint: disable=invalid-name

import argparse
import json

import requests
import semver


PACKAGE_EXCLUDE_JSON_URL = 'https://raw.githubusercontent.com/theforeman/foreman/develop/package-exclude.json'

def is_excluded(package, excludes):
    return (package in excludes['EXCLUDE_NPM_PACKAGES']
            or any(package.startswith(prefix) for prefix in excludes['EXCLUDE_NPM_PREFIXES']))


def get_requirement(version):
    if not version:
        raise ValueError('Empty version received')

    if version[0].isdigit():
        return ['= {}'.format(version)]

    if version.startswith('^') or version.startswith('~'):
        modifier = version[0]
        split_version = version[1:].split('.', 2)
        while(len(split_version) < 3):
            split_version.append('0')
        parsed = semver.parse('.'.join(split_version))

        min_version = '{}.{}.{}'.format(parsed['major'], parsed['minor'], parsed['patch'])
        if modifier == '^':
            max_version = '{}.0.0'.format(parsed['major'] + 1)
        elif modifier == '~':
            max_version = '{}.{}.0'.format(parsed['major'], parsed['minor'] + 1)

        return ['>= {}'.format(min_version), '< {}'.format(max_version)]

    if version.startswith('>=') or version.startswith('<'):
        return [version]

    raise ValueError('Unable to handle version {}'.format(version))


def get_requirements(dependencies, fmt, excludes):
    for package, version in sorted(dependencies.items()):
        if not is_excluded(package, excludes):
            name = f"npm({package})"
            requirements = [f'{name} {requirement}' for requirement in get_requirement(version)]
            if len(requirements) > 1:
                yield fmt.format(f'({" with ".join(requirements)})')
            else:
                yield fmt.format(requirements[0])


def get_npm_sections(packages, excludes):
    for section in ('devDependencies', 'dependencies'):
        for requires in ('BuildRequires', 'Requires'):
            trigger = '{} {}\n'.format(section, requires)
            deps = packages.get(section, {})
            requirements = list(get_requirements(deps, requires + ': {}\n', excludes))
            yield trigger, requirements


def get_specfile_sections(prefix, fp):
    trigger = prefix.replace('start', 'end', 1)
    key = None
    section = []

    for line in fp:
        if line.startswith(prefix):
            if key:
                raise Exception('Unclosed section {}'.format(key))

            key = strip_prefix(line, prefix)
            section = []
        elif key:
            if line.startswith(trigger):
                yield (key, section)
                key = None
            else:
                section.append(line.rstrip() + '\n')


def get_new_content(prefix, current_content, requires):
    key = None

    for line in current_content:
        if key:
            if line == key:
                yield line
                key = None
        else:
            yield line

            if line.startswith(prefix):
                key = strip_prefix(line, prefix)
                try:
                    for require in requires[key]:
                        yield require
                except KeyError:
                    raise SystemExit('Unrecognized section found: ' + line)
                key = prefix.replace('start', 'end') + key


def strip_prefix(line, prefix):
    return line[len(prefix):]


def main():
    parser = argparse.ArgumentParser(description='Update the dependencies within sections')
    parser.add_argument('requirementstype', help='the type of conversion',
                        choices=('npm', 'specfile', 'direct'))
    parser.add_argument('requirementsfile', help='Path to the requirements file',
                        type=argparse.FileType('r'))
    parser.add_argument('specfile', help='path to the specfile', type=argparse.FileType('r'))
    parser.add_argument('--excludefile', help='Path/URL to the package-exclude.json (default: %(default)s)', default=PACKAGE_EXCLUDE_JSON_URL)
    args = parser.parse_args()

    if args.requirementstype == 'npm':
        if args.excludefile.startswith('https://'):
            excludes = requests.get(args.excludefile).json()
        else:
            with open(args.excludefile) as excludesfile:
                excludes = json.load(excludesfile)

        prefix = '# start package.json '
        requires = dict(get_npm_sections(json.load(args.requirementsfile), excludes))
    elif args.requirementstype == 'specfile':
        prefix = '# start specfile '
        requires = dict(get_specfile_sections(prefix, args.requirementsfile))
    else:
        prefix = '# start '
        requires = json.load(args.requirementsfile)

    current_content = args.specfile.readlines()
    args.specfile.close()

    new_content = list(get_new_content(prefix, current_content, requires))

    with open(args.specfile.name, 'w') as fp:
        fp.writelines(new_content)


if __name__ == '__main__':
    main()
